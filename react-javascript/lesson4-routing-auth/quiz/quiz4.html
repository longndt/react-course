<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <title>Quiz - Routing & Authentication</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        "Helvetica Neue", Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
    }

    .header {
      background: white;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      margin-bottom: 30px;
      text-align: center;
    }

    .header h1 {
      color: #667eea;
      margin-bottom: 10px;
    }

    .header p {
      color: #666;
      font-size: 14px;
    }

    .progress-bar {
      background: white;
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      margin-bottom: 30px;
    }

    .progress-info {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 14px;
      color: #666;
    }

    .progress-track {
      width: 100%;
      height: 10px;
      background: #e0e0e0;
      border-radius: 5px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
    }

    .quiz-card {
      background: white;
      padding: 40px;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      margin-bottom: 30px;
    }

    .question-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .question-number {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
    }

    .question-text {
      font-size: 20px;
      font-weight: 600;
      color: #333;
      margin-bottom: 30px;
      line-height: 1.6;
    }

    .options {
      margin-bottom: 30px;
    }

    .option {
      background: #f8f9fa;
      padding: 15px 20px;
      margin-bottom: 12px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;
    }

    .option:hover {
      background: #e9ecef;
      transform: translateX(5px);
    }

    .option.selected {
      background: #e7e5ff;
      border-color: #667eea;
    }

    .option label {
      cursor: pointer;
      display: flex;
      align-items: center;
      width: 100%;
    }

    .option input[type="radio"] {
      margin-right: 15px;
      cursor: pointer;
      width: 20px;
      height: 20px;
    }

    /* Code styling in questions */
    .question-text code,
    .option code {
      background: #f1f5f9;
      padding: 3px 8px;
      border-radius: 6px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 16px;
      color: #e11d48;
      font-weight: 600;
      border: 1px solid #e2e8f0;
    }



    .short-answer-container {
      margin-bottom: 40px;
    }

    .short-answer-input {
      width: 100%;
      padding: 15px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      font-size: 16px;
      font-family: inherit;
      transition: border-color 0.3s ease;
    }

    .short-answer-input:focus {
      outline: none;
      border-color: #667eea;
    }

    .short-answer-actions {
      margin-top: 15px;
      text-align: center;
    }

    .buttons {
      display: flex;
      gap: 15px;
      justify-content: space-between;
    }

    .btn {
      padding: 12px 30px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .btn-secondary {
      background: white;
      color: #667eea;
      border: 2px solid #667eea;
    }

    .btn-secondary:hover {
      background: #f8f9fa;
    }

    .btn:disabled,
    .btn.disabled {
      opacity: 0.4;
      cursor: not-allowed;
      background-color: #e5e7eb;
      color: #9ca3af;
      border-color: #d1d5db;
      transform: none;
      box-shadow: none;
    }

    .btn:disabled:hover,
    .btn.disabled:hover {
      transform: none;
      box-shadow: none;
      background-color: #e5e7eb;
      color: #9ca3af;
    }

    .results-card {
      background: white;
      padding: 25px;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      text-align: center;
    }

    .score-circle {
      width: 140px;
      height: 140px;
      margin: 20px auto;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
    }

    .score-number {
      font-size: 42px;
      font-weight: bold;
    }

    .score-label {
      font-size: 13px;
      margin-top: 5px;
    }

    .score-details {
      margin: 15px 0;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 10px;
    }

    .score-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #e0e0e0;
      font-size: 14px;
    }

    .score-row:last-child {
      border-bottom: none;
    }

    .hidden {
      display: none;
    }

    .short-answer-input.correct {
      border-color: #10b981;
      background: #d1fae5;
    }

    .short-answer-input.incorrect {
      border-color: #ef4444;
      background: #fee2e2;
    }

    .option.correct {
      background: #d1fae5;
      border-color: #10b981;
    }

    .option.incorrect {
      background: #fee2e2;
      border-color: #ef4444;
    }

    .feedback-icon {
      margin-left: auto;
      font-size: 22px;
      font-weight: bold;
    }

    .answer-feedback {
      margin-top: 15px;
      padding: 14px 18px;
      border-radius: 10px;
      font-size: 15px;
      font-weight: 600;
      display: none;
    }

    .answer-feedback.show {
      display: block;
    }

    .answer-feedback.correct {
      background: #d1fae5;
      color: #065f46;
      border-left: 4px solid #10b981;
    }

    .answer-feedback.incorrect {
      background: #fee2e2;
      color: #991b1b;
      border-left: 4px solid #ef4444;
    }

    .buttons {
      margin-top: 30px;
    }


    .feedback {
      margin-top: 15px;
      padding: 15px;
      border-radius: 10px;
      font-size: 15px;
    }

    .feedback.excellent {
      background: #d4edda;
      color: #155724;
    }

    .feedback.good {
      background: #d1ecf1;
      color: #0c5460;
    }

    .feedback.average {
      background: #fff3cd;
      color: #856404;
    }

    .feedback.needs-improvement {
      background: #f8d7da;
      color: #721c24;
    }

    /* Accessibility - Screen reader only text */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    /* Semantic HTML updates */
    .options {
      border: none;
      padding: 0;
      margin: 0;
    }

    @media (max-width: 600px) {

      .quiz-card,
      .results-card {
        padding: 20px;
      }

      .question-text {
        font-size: 18px;
      }

      .buttons {
        flex-direction: column;
      }

      .btn {
        width: 100%;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Header -->
    <header class="header" role="banner">
      <h1> Quiz - Routing & Authentication</h1>
    </header>

    <!-- Main Content -->
    <main role="main">
      <!-- Progress Bar -->
      <section class="progress-bar" id="progressBar" aria-label="Quiz Progress">
        <div class="progress-info">
          <span id="progressText" aria-live="polite">Question 1 of 20</span>
          <span id="answeredText" aria-live="polite">Answered: 0/20</span>
        </div>
        <div class="progress-track" role="progressbar" aria-valuenow="5" aria-valuemin="0" aria-valuemax="100"
          aria-label="Quiz completion progress">
          <div class="progress-fill" id="progressFill"></div>
        </div>
      </section>

      <!-- Quiz Card -->
      <article class="quiz-card" id="quizCard" role="form" aria-labelledby="questionText">
        <div class="question-header">
          <span class="question-number" id="questionNumber" aria-label="Current question number">Question 1</span>
        </div>

        <h2 class="question-text" id="questionText" role="heading" aria-level="2"></h2>

        <!-- Multiple Choice Options -->
        <fieldset class="options" id="optionsContainer" aria-label="Answer options"></fieldset>

        <!-- Short Answer Input -->
        <div class="short-answer-container hidden" id="shortAnswerContainer">
          <label for="shortAnswerInput" class="sr-only">Your answer</label>
          <input type="text" class="short-answer-input" id="shortAnswerInput" placeholder="Type your answer here..."
            aria-label="Short answer input field" aria-describedby="shortAnswerFeedback" />
          <div class="answer-feedback" id="shortAnswerFeedback" role="status" aria-live="polite"></div>
          <div class="short-answer-actions">
            <button class="btn btn-secondary" id="skipBtn" aria-label="Skip this question">
              Skip Question
            </button>
          </div>
        </div>

        <nav class="buttons" aria-label="Quiz navigation">
          <button class="btn btn-secondary" id="prevBtn" disabled aria-label="Go to previous question">
            ← Previous
          </button>
          <button class="btn btn-primary" id="nextBtn" disabled aria-label="Go to next question">Next →</button>
        </nav>
      </article>
    </main>

    <!-- Results Card -->
    <section class="results-card hidden" id="resultsCard" role="region" aria-labelledby="resultsTitle"
      aria-live="polite">
      <h2 id="resultsTitle" style="color: #667eea; margin-bottom: 12px; font-size: 24px">
        Quiz Completed!
      </h2>

      <div class="score-circle" role="img" aria-label="Score visualization">
        <div class="score-number" id="scoreNumber" aria-label="Your quiz score">0%</div>
        <div class="score-label">Your Score</div>
      </div>

      <div class="score-details">
        <div class="score-row">
          <span><strong>Total Questions:</strong></span>
          <span id="totalQuestions">20</span>
        </div>
        <div class="score-row">
          <span><strong>Answered:</strong></span>
          <span id="answeredCount">0</span>
        </div>
        <div class="score-row">
          <span><strong>Correct:</strong></span>
          <span id="correctCount">0</span>
        </div>
        <div class="score-row">
          <span><strong>Skipped:</strong></span>
          <span id="skippedCount">0</span>
        </div>
      </div>

      <div class="feedback" id="feedback" role="status"></div>

      <button class="btn btn-primary" style="margin-top: 20px" onclick="location.reload()"
        aria-label="Restart the quiz">
        Retake Quiz
      </button>
    </section>
  </div>

  <script>
    // Quiz Data - Routing & Authentication (Based on theory4.md)
    const quizData = [
      // Multiple Choice Questions (1-15)
      {
        type: "multiple",
        question: "What is the main advantage of client-side routing in React?",
        options: [
          "Faster server responses",
          "No page reloads, instant navigation with state persistence",
          "Better SEO",
          "Smaller bundle size",
        ],
        correct: 1,
      },
      {
        type: "multiple",
        question: "Which library is the standard for routing in React?",
        options: ["React Navigation", "React Router", "Next Router", "Express Router"],
        correct: 1,
      },
      {
        type: "multiple",
        question: "What component wraps the entire app to enable routing?",
        options: ["Router", "BrowserRouter", "Routes", "Route"],
        correct: 1,
      },
      {
        type: "multiple",
        question: "Which component is used for declarative navigation in React Router?",
        options: ["<a>", "<Link>", "<Navigate>", "<Redirect>"],
        correct: 1,
      },
      {
        type: "multiple",
        question: "What is a protected route?",
        options: [
          "A route that loads faster",
          "A route that requires authentication to access",
          "A route with HTTPS",
          "A route without parameters",
        ],
        correct: 1,
      },
      {
        type: "multiple",
        question: "What does JWT stand for?",
        options: [
          "JavaScript Web Token",
          "JSON Web Token",
          "Java Web Technology",
          "Just Working Token",
        ],
        correct: 1,
      },
      {
        type: "multiple",
        question: "Where should you store JWT tokens in the browser?",
        options: [
          "In global variables",
          "In localStorage or httpOnly cookies",
          "In the URL",
          "In CSS files",
        ],
        correct: 1,
      },
      {
        type: "multiple",
        question: "What is the purpose of useNavigate hook?",
        options: [
          "To create navigation menus",
          "To programmatically navigate between routes",
          "To fetch navigation data",
          "To style navigation components",
        ],
        correct: 1,
      },
      {
        type: "multiple",
        question: "What hook is used to access URL parameters?",
        options: ["useState", "useEffect", "useParams", "useRouter"],
        correct: 2,
      },
      {
        type: "multiple",
        question: "What is Role-Based Access Control (RBAC)?",
        options: [
          "A routing pattern",
          "Restricting access based on user roles/permissions",
          "A database design pattern",
          "A CSS methodology",
        ],
        correct: 1,
      },
      {
        type: "multiple",
        question: "What component is used as a placeholder for nested routes?",
        options: ["<Children>", "<Outlet>", "<Nested>", "<Slot>"],
        correct: 1,
      },
      {
        type: "multiple",
        question: "What is the purpose of authentication?",
        options: [
          "To make apps faster",
          "To verify user identity and control access",
          "To improve SEO",
          "To reduce bundle size",
        ],
        correct: 1,
      },
      {
        type: "multiple",
        question: "What should you do when a JWT token expires?",
        options: [
          "Ignore it",
          "Refresh the token or redirect to login",
          "Delete the app",
          "Change the password",
        ],
        correct: 1,
      },
      {
        type: "multiple",
        question: "What is the difference between authentication and authorization?",
        options: [
          "No difference",
          "Authentication verifies identity, authorization checks permissions",
          "Authorization is faster",
          "Authentication is only for admins",
        ],
        correct: 1,
      },
      {
        type: "multiple",
        question: "What is a common security practice for storing passwords?",
        options: [
          "Store in plain text",
          "Hash with bcrypt or similar algorithms",
          "Encrypt with base64",
          "Store in localStorage",
        ],
        correct: 1,
      },

      // Short Answer Questions (16-20)
      {
        type: "short",
        question: "What React Router component defines individual routes?",
        answer: "Route",
      },
      {
        type: "short",
        question: "What hook returns the current location object in React Router?",
        answer: "useLocation",
      },
      {
        type: "short",
        question: "What component should render when no routes match (404 page)?",
        answer: "NotFound",
      },
      {
        type: "short",
        question: "What HTTP status code indicates unauthorized access?",
        answer: "401",
      },
      {
        type: "short",
        question: "What React pattern is commonly used to share auth state across components?",
        answer: "Context",
      },
    ];

    // State
    let currentQuestion = 0;
    let userAnswers = new Array(quizData.length).fill(null);
    let answerChecked = new Array(quizData.length).fill(false);

    // DOM Elements
    const progressText = document.getElementById("progressText");
    const answeredText = document.getElementById("answeredText");
    const progressFill = document.getElementById("progressFill");
    const questionNumber = document.getElementById("questionNumber");
    const questionText = document.getElementById("questionText");
    const optionsContainer = document.getElementById("optionsContainer");
    const shortAnswerContainer = document.getElementById(
      "shortAnswerContainer"
    );
    const shortAnswerInput = document.getElementById("shortAnswerInput");
    const shortAnswerFeedback = document.getElementById("shortAnswerFeedback");
    const skipBtn = document.getElementById("skipBtn");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const quizCard = document.getElementById("quizCard");
    const resultsCard = document.getElementById("resultsCard");

    // Initialize Quiz
    function init() {
      // Shuffle options for all multiple choice questions
      quizData.forEach(question => {
        if (question.type === "multiple") {
          const correctAnswer = question.options[question.correct];
          // Shuffle options
          const shuffled = [...question.options];
          for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
          }
          question.options = shuffled;
          // Update correct index
          question.correct = shuffled.indexOf(correctAnswer);
        }
      });

      showQuestion(currentQuestion);
    }


    // Check multiple choice answer
    function checkAnswer(index, selectedOption) {
      const question = quizData[index];
      answerChecked[index] = true;

      const options = document.querySelectorAll(".option");
      options.forEach((opt, i) => {
        const input = opt.querySelector("input");
        input.disabled = true;
        opt.style.cursor = "default";

        if (i === question.correct) {
          opt.classList.add("correct");
          opt.classList.remove("selected");
          // Check if icon already exists
          if (!opt.querySelector(".feedback-icon")) {
            const icon = document.createElement("span");
            icon.className = "feedback-icon";
            icon.textContent = "✓";
            opt.querySelector("label").appendChild(icon);
          }
        } else if (i === selectedOption) {
          opt.classList.add("incorrect");
          opt.classList.remove("selected");
          // Check if icon already exists
          if (!opt.querySelector(".feedback-icon")) {
            const icon = document.createElement("span");
            icon.className = "feedback-icon";
            icon.textContent = "✗";
            opt.querySelector("label").appendChild(icon);
          }
        }
      });

      // Enable Next button after answer is checked
      nextBtn.disabled = false;
    }

    // Check short answer
    function checkShortAnswer(index, answer) {
      const question = quizData[index];
      answerChecked[index] = true;

      const isCorrect = answer.toLowerCase().trim() === question.answer.toLowerCase().trim();

      shortAnswerInput.disabled = true;
      shortAnswerInput.classList.add(isCorrect ? "correct" : "incorrect");

      shortAnswerFeedback.classList.add("show", isCorrect ? "correct" : "incorrect");
      shortAnswerFeedback.textContent = isCorrect
        ? `✓ Correct! The answer is "${question.answer}"`
        : `✗ Incorrect. The correct answer is "${question.answer}"`;

      // Enable Next button after answer is checked
      nextBtn.disabled = false;
    }

    // Show Question
    function showQuestion(index) {
      const question = quizData[index];

      // Update header
      questionNumber.textContent = `Question ${index + 1}`;
      questionText.textContent = question.question || "Question text missing";

      // Update progress
      progressText.textContent = `Question ${index + 1} of ${quizData.length
        }`;
      const answered = userAnswers.filter((a) => a !== null).length;
      answeredText.textContent = `Answered: ${answered}/${quizData.length}`;
      progressFill.style.width = `${((index + 1) / quizData.length) * 100}%`;

      // Clear previous
      optionsContainer.innerHTML = "";
      shortAnswerInput.value = "";
      shortAnswerFeedback.classList.remove('show', 'correct', 'incorrect');
      shortAnswerFeedback.textContent = "";

      if (question.type === "multiple") {
        // Show multiple choice
        optionsContainer.classList.remove("hidden");
        shortAnswerContainer.classList.add("hidden");

        question.options.forEach((option, i) => {
          const div = document.createElement("div");
          div.className = "option";

          // Check if answer was already checked
          if (answerChecked[index]) {
            if (i === question.correct) {
              div.classList.add("correct");
            } else if (userAnswers[index] === i && i !== question.correct) {
              div.classList.add("incorrect");
            }
          } else if (userAnswers[index] === i) {
            div.classList.add("selected");
          }

          div.innerHTML = `<label><input type="radio" name="answer" value="${i}" ${userAnswers[index] === i ? "checked" : ""} ${answerChecked[index] ? "disabled" : ""}><span>${option}</span>${answerChecked[index] && i === question.correct ? '<span class="feedback-icon">✓</span>' : ''}${answerChecked[index] && userAnswers[index] === i && i !== question.correct ? '<span class="feedback-icon">✗</span>' : ''}</label>`;

          if (!answerChecked[index]) {
            div.addEventListener("click", () => {
              document
                .querySelectorAll(".option")
                .forEach((o) => o.classList.remove("selected"));
              div.classList.add("selected");
              div.querySelector("input").checked = true;
              userAnswers[index] = i;
              updateProgress();

              // Immediate feedback
              checkAnswer(index, i);
            });
          }

          optionsContainer.appendChild(div);
        });
      } else {
        // Show short answer
        optionsContainer.classList.add("hidden");
        shortAnswerContainer.classList.remove("hidden");

        if (userAnswers[index]) {
          shortAnswerInput.value = userAnswers[index];

          // Show feedback if already checked
          if (answerChecked[index]) {
            checkShortAnswer(index, userAnswers[index]);
          }
        }


        shortAnswerInput.disabled = answerChecked[index];

        shortAnswerInput.oninput = () => {
          userAnswers[index] = shortAnswerInput.value.trim();
          updateProgress();

          // Enable/disable Next button based on input content
          if (userAnswers[index] && !answerChecked[index]) {
            nextBtn.disabled = false;
            nextBtn.classList.remove('disabled');
          } else if (!userAnswers[index] && !answerChecked[index]) {
            nextBtn.disabled = true;
            nextBtn.classList.add('disabled');
          }
        };

        shortAnswerInput.onblur = () => {
          if (userAnswers[index] && !answerChecked[index]) {
            checkShortAnswer(index, userAnswers[index]);
          }
        };

        // Enter key to check answer
        shortAnswerInput.onkeypress = (e) => {
          if (e.key === 'Enter' && userAnswers[index] && !answerChecked[index]) {
            checkShortAnswer(index, userAnswers[index]);
            shortAnswerInput.blur();
          }
        };
        // Skip button functionality
        skipBtn.onclick = () => {
          if (!answerChecked[index]) {
            userAnswers[index] = ""; // Mark as skipped
            answerChecked[index] = true;
            shortAnswerInput.disabled = true;
            skipBtn.disabled = true;
            nextBtn.disabled = false;
            updateProgress();
          }
        };
      }

      // Update buttons
      prevBtn.disabled = index === 0;
      nextBtn.textContent =
        index === quizData.length - 1 ? "Submit Quiz" : "Next →";

      // Enable/disable Next button based on answer status
      if (question.type === "short") {
        // For short answer, disable if not answered AND no text in input
        nextBtn.disabled = !answerChecked[index] && (!userAnswers[index] || userAnswers[index].trim() === '');
        if (nextBtn.disabled) {
          nextBtn.classList.add('disabled');
        } else {
          nextBtn.classList.remove('disabled');
        }
      } else {
        // For multiple choice, disable if not answered
        nextBtn.disabled = !answerChecked[index];
        nextBtn.classList.remove('disabled');
      }

      // Reset skip button state
      skipBtn.disabled = answerChecked[index];
    }

    // Update Progress
    function updateProgress() {
      const answered = userAnswers.filter((a) => a !== null && a !== "")
        .length;
      answeredText.textContent = `Answered: ${answered}/${quizData.length}`;

      // Update ARIA progress bar
      const progressPercentage = ((currentQuestion + 1) / quizData.length) * 100;
      const progressTrack = document.querySelector('.progress-track');
      if (progressTrack) {
        progressTrack.setAttribute('aria-valuenow', Math.round(progressPercentage));
      }
    }

    // Next Question
    nextBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();

      // Only proceed if current question is answered/checked
      if (answerChecked[currentQuestion]) {
        if (currentQuestion < quizData.length - 1) {
          currentQuestion++;
          showQuestion(currentQuestion);
        } else {
          showResults();
        }
      }
    });

    // Previous Question
    prevBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();

      if (currentQuestion > 0) {
        currentQuestion--;
        showQuestion(currentQuestion);
      }
    });

    // Show Results
    function showResults() {
      let correct = 0;
      let answered = 0;

      quizData.forEach((question, index) => {
        const userAnswer = userAnswers[index];

        if (userAnswer !== null && userAnswer !== "") {
          answered++;

          if (question.type === "multiple") {
            if (userAnswer === question.correct) {
              correct++;
            }
          } else {
            // Short answer - case insensitive comparison
            if (
              userAnswer.toLowerCase().trim() ===
              question.answer.toLowerCase().trim()
            ) {
              correct++;
            }
          }
        }
      });

      const skipped = quizData.length - answered;
      const percentage = answered > 0 ? (correct / answered) * 100 : 0;

      // Update results
      document.getElementById("scoreNumber").textContent =
        Math.round(percentage) + "%";
      document.getElementById("totalQuestions").textContent = quizData.length;
      document.getElementById("answeredCount").textContent = answered;
      document.getElementById("correctCount").textContent = correct;
      document.getElementById("skippedCount").textContent = skipped;

      // Feedback
      const feedback = document.getElementById("feedback");
      if (percentage >= 90) {
        feedback.className = "feedback excellent";
        feedback.textContent =
          " Excellent! You have a strong grasp of React Router and authentication fundamentals!";
      } else if (percentage >= 70) {
        feedback.className = "feedback good";
        feedback.textContent =
          "👍 Good job! You understand most React Router and authentication concepts well!";
      } else if (percentage >= 50) {
        feedback.className = "feedback average";
        feedback.textContent =
          " Not bad! Review the materials to improve your understanding.";
      } else {
        feedback.className = "feedback needs-improvement";
        feedback.textContent =
          "💪 Keep studying! Practice more to master React Router and authentication fundamentals.";
      }

      // Show results
      quizCard.classList.add("hidden");
      document.getElementById("progressBar").classList.add("hidden");
      resultsCard.classList.remove("hidden");
    }

    // Start quiz
    init();
  </script>
</body>

</html>